* Hello ~chrdev~

  A learning module created by simplifying the scull module presented in [[https://lwn.net/images/pdf/LDD3/ch03.pdf][chapter 3]] of [[https://lwn.net/Kernel/LDD3/][/Linux Device Drivers, Third Edition/]].

  ~cat /dev/hello-dev0~ will output "Hello world" once the module has been loaded. Any user can write to the device to update the greeting like ~echo -n "Bob" > /dev/hello-dev0~.
  After which ~cat /dev/hello-dev0~ will output "Hello Bob".

** Loading and Unloading the Module
*** Structs and Macros

    We need to set up some things so that our "Hello" greeting can have a ~target~ other than "world".

    #+name: global-target_max_len
    #+begin_src c :noweb yes
      #ifndef TARGET_MAX_LEN
      #define TARGET_MAX_LEN 64
      #endif
    #+end_src

    ~TARGET_MAX_LEN~ is the maximum length of the name we'll store. This /could/ be set up as a load time parameter. However, since how the driver's major version is passed
    at load time is an example of a module parameter, a compile time parameter is simpler and sufficient here.

    #+name: global-struct-hello_dev
    #+begin_src c :noweb yes
      struct hello_dev {
	char target[TARGET_MAX_LEN + 1];
	struct cdev cdev;
      };
    #+end_src

    The ~hello_dev~ struct will be used later to keep the ~target~, initially "world", associated with a specific device. This pattern enables creating multiple devices,
    like ~/dev/hello-dev0~ and ~/dev/hello-dev1~, that each have independent state. This makes it easier to transition from a single device to multiple devices.

*** Major Number Parameter

    Each device has a major and minor number. The major is used by the kernel to determine which driver manages a devices. The minor is used to distinguish devices that
    are managed by the same driver. The major and minor numbers can be seen in ~ls -l /dev/null~ output.

    #+begin_src shell
      $ ls -l /dev/null
      crw-rw-rw- 1 root root 1, 3 Jun 29 17:51 /dev/null
    #+end_src

    In this case the major number is 1 and the minor number is 3. We can check in ~/proc/devices~ to see what driver manages ~/dev/null~.

    #+begin_src shell
      $ grep " 1 " /proc/devices
       1 mem
    #+end_src

    We see that the ~mem~ driver handles ~/dev/null~ on this system.

    Using a fixed major number can cause driver conflicts down the road, but being flexible is not without issue. We won't know what the major number is until after the
    module is loaded so we can't create nodes in ~/dev~ before the module is loaded. The scull driver is not opinionated here. It allows setting the major number at compile 
    time or load time and it will get a major number dynamically if one isn't set in advance. To keep things simpler this driver only allows a dynamic major number. We'll 
    account for it the same way the ~scull_load~ does in ~hello-dev-load.sh~.

    #+name: global-hello_numbers
    #+begin_src c :noweb yes
      int hello_major = 0;
      int hello_minor = 0;
    #+end_src

    We'll use these globals to store the major and minor numbers.

*** Loading

    To be useful our driver needs to get a major number and initialize the state for the devices when it is loaded.

    #+name: init-get-major-number
    #+begin_src c :noweb yes
      dev_t dev;
      int result = 0;

      result = alloc_chrdev_region(&dev, hello_minor, 1, "hello-dev");
      hello_major = MAJOR(dev);

      if (result < 0) {
	printk(KERN_WARNING "hello: can't get major %d", hello_major);
	return result;
      }
    #+end_src

    To get a major number for our driver we'll call [[https://www.kernel.org/doc/htmldocs/kernel-api/API-alloc-chrdev-region.html][~alloc_chrdev_region~]], failing if the ~result~ of that call is negative.

    ~alloc_chrdev_region~ needs:
    1. A place to store the result. We're using ~dev_t dev~. ~dev_t~ is an integer type that represents the major and minor numbers for a device.
    2. The first minor number to use. We've set ~hello_minor = 0~ above.
    3. The number of devices to create.
    4. A string name for the driver that will manage the devices. We'll use this later when we check for the major number in ~/proc/devices~
       
       
    The ~MAJOR~ macro gets the major number from ~dev~ so it can be stored.
    
    Now that we've got a major number we can prepare the device!

    #+name: global-device
    #+begin_src c :noweb yes
      struct hello_dev *device;
    #+end_src

    ~device~ gives us a global place to keep track of where the state for devices is in memory. If we were using more than one device we'd use an array of 
    ~struct hello_dev *~ here instead.

    #+name: init-prepare-device-zero
    #+begin_src c :noweb yes
      device = kmalloc(sizeof(struct hello_dev), GFP_KERNEL);
      if (!device) {
	result = -ENOMEM;
       }
      memset(device, 0, sizeof(struct hello_dev));
    #+end_src

    We allocate some space to store the state using [[https://www.kernel.org/doc/htmldocs/kernel-api/API-kmalloc.html][~kmalloc~]]. We'll have to free it when the module is unloaded. If the allocation fails we'll return a no memory error.
    We also make sure to zero the memory out using ~memset~ because kernel memory is shared between modules. Zeroing reduces the risk that some secret data will get leaked.

    ~kmalloc~ needs:
    1. The number of bytes to allocate. We need enough to store an instance of ~struct hello_dev~.
    2. The type of memory to allocate. All we need for now is normal kernel ram.


    #+name: global-hello_fops
    #+begin_src c :noweb yes
      struct file_operations hello_fops = {
	.owner = THIS_MODULE,
	.read = hello_read,
	.write = hello_write,
	.open = hello_open,
	.release = hello_release,
      };
    #+end_src

    We'll implement these functions later so that our driver can provide read and write capability.

    #+name: init-prepare-device-setup
    #+begin_src c :noweb yes
      cdev_init(&device->cdev, &hello_fops);
      device->cdev.owner = THIS_MODULE;
      device->cdev.ops = &hello_fops;
    #+end_src

    We set the device up by initializing it with [[https://www.kernel.org/doc/htmldocs/kernel-api/API-cdev-init.html][~cdev_init~]] since we're embedding a ~struct cdev~ in the ~struct hello_dev~. Once initalized we set the ~owner~ and point
    ~ops~ at a ~struct file_operations~ which points at functions to call for things like reading and writing from the device. ~THIS_MODULE~ is a kernel macro that points
    to the running module.

    ~cdev_init~ needs:
    1. A pointer to the memory to initalize. We're using ~cdev~ on ~device~.
    2. A pointer to the file operations. We're using ~&hello_fops~ (the functions will be defined later).


    #+name: init-greeting-target
    #+begin_src c :noweb yes
      char *default_target = "world";
      memcpy(device->target, default_target, strlen(default_target));
    #+end_src

    We set up the default target of the greeting by copying it into the recently allocated space for ~device~ using ~memcpy~.

    #+name: init-add-cdev
    #+begin_src c :noweb yes
      int error;
      error = cdev_add(&device->cdev, dev, 1);
      if (error) {
	printk(KERN_NOTICE "Error %d adding hello%d", error, dev);
      }
    #+end_src

    Finally we can add the device using [[https://www.kernel.org/doc/htmldocs/kernel-api/API-cdev-add.html][~cdev_add~]], logging a message if there is any problem.

    ~cdev_add~ needs:
    1. A pointer to the device to add. We're using the ~cdev~ which was recently initalized on ~device~.
    2. The first device number this driver handles. ~dev~ is set to this early on during module loading.
    3. The number of minor numbers to add for this driver. We're only using a single device so 1 is fine.


    #+name: global-module_init
    #+begin_src c :noweb yes
      module_init(hello_init);
    #+end_src

    We wrap this loading functionality up in ~static int hello_init(void)~ and use [[https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-init-again.html][~module_init~]] to tell the kernel how to load the module.

    #+name: global-hello_init
    #+begin_src c :noweb yes :exports none
      static int hello_init(void) {
	<<init-get-major-number>>

	<<init-prepare-device-zero>>

	<<init-prepare-device-setup>>

	<<init-greeting-target>>

	<<init-add-cdev>>

	return result;
      }
    #+end_src

*** Unloading

    Unloading this module is a bit simpler. We have to free the memory we allocated and unregister the driver.

    #+name: exit-kfree
    #+begin_src c :noweb yes
      kfree(device);
    #+end_src

    Memory is freed using [[https://www.kernel.org/doc/htmldocs/kernel-api/API-kfree.html][~kfree~]] which needs a pointer that was returned by ~kmalloc~. We're using ~device~ which was allocated when the module was loaded.

    #+name: exit-unregister_chrdev_region
    #+begin_src c :noweb yes
      dev_t dev_num = MKDEV(hello_major, hello_minor);
      unregister_chrdev_region(dev_num, 1);
    #+end_src

    We use [[https://www.kernel.org/doc/htmldocs/kernel-api/API-unregister-chrdev-region.html][~unregister_chrdev_region~]] to release the device we allocated with ~alloc_chrdev_region~ when the module was loaded.

    ~unregister_chrdev_region~ needs:
    1. The first device number in the region. We're using ~MKDEV~ to build that based on ~hello_major~ and ~hello_minor~.
    2. The number of devices. We allocated one when the module was loaded.


    #+name: global-module_exit
    #+begin_src c :noweb yes
      module_exit(hello_exit);
    #+end_src

    We wrap this up in ~static void hello_exit(void)~ and use [[https://www.kernel.org/doc/htmldocs/kernel-hacking/routines-moduleexit.html][~module_exit~]] to let the kernel know how to unload the module.

    #+name: global-hello_exit
    #+begin_src c :noweb yes :exports none
      static void hello_exit(void) {
	<<exit-kfree>>

	<<exit-unregister_chrdev_region>>

	return;
      }
    #+end_src

** Opening and Closing a Device
*** Opening

    A more sophisticated driver might have multiple devices and need to know which one is being opened. The open function is passed a ~struct inode *~ which contians a pointer
    to ~cdev~ on ~device~. If we managed more than one device we'd use [[https://www.kernel.org/doc/html/latest/driver-api/driver-model/design-patterns.html#container-of][~container_of~]] to determine /which/ device in our array of ~struct hello_dev~ was being opened. Once we 
    have a pointer to a ~struct hello_dev~ it can be placed in ~struct file~'s ~private_data~ so that read and write functions have access to the device state.

    #+name: open-zero-target
    #+begin_src c :noweb yes
      if ((f->f_flags & O_ACCMODE) == O_WRONLY) {
	memset(device->target, 0, TARGET_MAX_LEN + 1);
      }
    #+end_src

    This module doesn't have much setup to do on open. If the device file was opened write only then we zero out the ~target~ in anticipation of new data. We wrap it up in a
    ~int hello_open (struct inode *i, struct file *f)~ so it matches what ~struct file_operations~ expects.

    #+name: global-hello_open
    #+begin_src c :noweb yes :exports none
      int hello_open(struct inode *i, struct file *f) {
	<<open-zero-target>>
  
	return 0;
      }
    #+end_src

*** Closing

    Easy setup makes for easy cleanup. There would be more to consider on the release side if the driver was more sophisticated.

    #+name: global-hello_release
    #+begin_src c :noweb yes
      int hello_release(struct inode *i, struct file *f) {
	return 0;
      }
    #+end_src

    The function signature must match what is expected by ~struct file_operations~ like it does for ~hello_open~.
    
** Reading and Writing Devices
*** Reading

    Our read function will be called by the kernel when something else tries to read from our device file. The kernel will pass us a ~struct file *~ so we can determine which
    device is being read from. If the driver were more sophisticated we would have made the ~private_data~ field of the ~file~ struct a pointer to our ~device~. That way we'd
    be able to access any state we had stored for the device. Since this driver only manages one device we can skip that detail.

    #+name: read-setup-data
    #+begin_src c :noweb yes
      char data[72] = "Hello ";
      memcpy(data + strlen(data), device->target, strlen(device->target));
    #+end_src

    We build up our greeting string so that it can be copied into user memory later.

    #+name: read-handle-read-conditions
    #+begin_src c :noweb yes
      long leftover, transferred;

      if (*offset > strlen(data)) {
	transferred = 0;
      } else if (read_amount > strlen(data)) {
	leftover = copy_to_user(buf, data + *offset, strlen(data) + 1);
	transferred = strlen(data) + 1 - leftover;
      } else {
	leftover = copy_to_user(buf, data + *offset, read_amount);
	transferred = read_amount - leftover;
      }
    #+end_src

    When our read function is called it'll get the amount of data the caller is prepared to read as a ~size_t~ and an ~loff_t *~ that specifies the offset before the read. We'll
    update that offset after data is copied to user memory. 

    Before we go copying from kernel memory to user memory we need to check a couple things:
    1. Is the offset past the end of the data we have to read? 
       1. Set the amount of data ~transferred~ to zero since there is nothing left to read
    2. Is the amount of data requested greater than the amount of data we have to read? 
       1. Copy all of the data to user memory tracking any that failed to copy in ~leftover~
       2. Set the amount of data ~transferred~ to be the length of ~data~, and a trailing null, minus whatever ~copy_to_user~ missed
    3. Otherwise the offset must be before the end of readable data and the amount of data requested must be less than the amount that can be read
       1. Copy the requested amount of data to user memory tracking any that failed to copy in ~leftover~
       2. Set the amount of data ~transferred~ to be the amount requested minus whatever ~copy_to_user~ missed

    We can't directly copy from kernel memory to user memory. Instead we need to use [[https://www.kernel.org/doc/html/v4.16/kernel-hacking/hacking.html#copy-to-user-copy-from-user-get-user-put-user][~copy_to_user~]] to move data around.

    ~copy_to_user~ needs:
    1. A destination pointer in user memory
    2. A source pointer in kernel memory
    3. How many bytes to copy


    #+name: read-wrap-up
    #+begin_src c :noweb yes
      *offset = *offset + transferred;

      return transferred;
    #+end_src

    Advance the offset based on how much data was successfully transferred. The function is also expected to return how much data was successfully moved.

    Wrap the read logic up in ~ssize_t hello_read(struct file *f, char __user *buf, size_t read_amount, loff_t *offset)~ so that it can be used in a ~file_operations~ struct.
    The ~__user~ on ~char __user *buf~ lets us know that the pointer is in user memory, not kernel memory.

    #+name: global-hello_read
    #+begin_src c :noweb yes :exports none
      ssize_t hello_read(struct file *f, char __user *buf, size_t read_amount, loff_t *offset) {
	<<read-setup-data>>

	<<read-handle-read-conditions>>

	<<read-wrap-up>>
      }
    #+end_src

*** TODO Writing
** TODO Building the Module
*** TODO ~Makefile~
** TODO Using It!
*** TODO ~hello-dev-load.sh~
*** TODO ~hello-dev-unload.sh~
*** TODO Interacting with the Device File

#+begin_src c :noweb yes :tangle hello-dev.c :exports none
  // this file is generated using org and babel from hello-chrdev.org
  #include <asm-generic/fcntl.h>
  #include <linux/cdev.h>
  #include <linux/fs.h>
  #include <linux/init.h>
  #include <linux/kdev_t.h>
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/slab.h>

  <<global-target_max_len>>

  <<global-struct-hello_dev>>

  <<global-device>>

  <<global-hello_open>>

  <<global-hello_release>>

  <<global-hello_read>>

  <<global-hello_fops>>

  <<global-hello_init>>

  <<global-hello_exit>>

  <<global-module_init>>
  <<global-module_exit>>
#+end_src
